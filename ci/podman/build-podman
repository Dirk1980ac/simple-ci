#!/bin/env bash

# SPDX-License-Identifier: MIT

# Exit on error and on unbound variables
set -eu

# --- User ccnfiguration: ---

# Registry information
REG_USER="dirk1980" # Registry username (Used to generate the image path)
REG_ADDR="docker.io" # Registry to use (Used to generate the image path)

# Signature files
SIGN_PRIVATE_KEY="${HOME}/.ci/.podman/$REG_USER.private" # Private key for signing
SIGN_PASSWORD_FILE="${HOME}/.ci/.podman/$REG_USER.pw" # Key password file

# Encryption key
ENCRYPT_KEY="jwe:${HOME}/.ci/.podman/$REG_USER-encrypt.pub" # Private key for signing

# Podman authfile
AUTHFILE="$HOME/.ci/.podman/auth.json" # Registry authentication token

# --- End of user configuration ---

# Initialize script variables because we use 'set -u'
PROJECT=""
WORKDIR=""
UPLOAD="false"
BUILD_ID="missing"
ARCHES=()
ENCRYPT="false"

# Print a hopefully useful help text.
help() {
	cat << EOF
Usage: $(basename "$0") [OPTIONS]

This script builds a multi-architecture Podman image for a specified project
and can optionally upload it, targeting either a 'stable' or 'nightly' release.

Options:
  -p <project>, --project=<project>
      Sets the **project name**. This option is **mandatory**.

  -w <directory>, --workdir=<directory>
      Specifies the **working directory** where the build context is located.
      This option is **mandatory**.

  -b <id>, --build-id=<id>
      Assigns a **build ID** to the image, which can be used for versioning or tracking.
      This option is **mandatory**.

  --arch
      Arch to build. Can be used multiple times to build multiple images.

  --encrypt
      Encrypt the image before push.

  -u, --upload
      If provided, the built image will be **uploaded** (pushed) to the configured server.
      For 'stable' builds, the image will also be pushed as 'latest'.
      This option is optional.

  -h, --help
      Displays this help message and exits.

Examples:
  bootc-build -p myapp -w ./src -b 12345 -t nightly --upload
  bootc-build --project=another-app --workdir=/opt/build/app --build-id=v1.2.0 --target=stable
  bootc-build -p test-project -w /tmp/build -b abc-789 -t nightly -u

EOF
	exit 1
}

# Parse command line options
if ! ARGS=$(getopt -o p:w:b:uha: --long project:,workdir:,build-id:,upload,help,arch:,encrypt -n "build-podman" -- "$@"); then
	echo "Error: Failed to parse options. Please check your command." >&2
	help
fi

eval set -- "$ARGS"

while true; do
	case "$1" in
		-p | --project)
			PROJECT=$2
			shift 2
			;;
		-w | --workdir)
			WORKDIR=$2
			shift 2
			;;
		-b | --build-id)
			BUILD_ID=$2
			shift 2
			;;
		-a | --arch)
			ARCHES+=("$2")
			shift 2
			;;
		-u | --upload)
			UPLOAD="true"
			shift
			;;
		-h | --help)
			help
			;;
		--encrypt)
			ENCRYPT="true"
			;;
		--) # End of options
			shift
			break
			;;
		*)
			echo "Internal error in option parsing!" >&2
			exit 1
			;;
	esac
done

# Show help if a mandatory option is missing
if [ -z "$PROJECT" ] || [ -z "$BUILD_ID" ] || [ -z "$WORKDIR" ]; then
	echo "Error: Mandatory options --project, --build-id or --workdir missing." >&2
	help
fi

LOCKFILE="$HOME/.ci/build/locks/.${PROJECT}-running"

# cleanup function
cleanup() {
	# Remove lock file
	rm -f "${LOCKFILE}"
}

# Trap for cleanup: Ensures lock file is removed even on script to error or signal.
trap cleanup EXIT

# Check if the desired build is already running
if [ ! -f "${LOCKFILE}" ]; then
	# Lock the build to avoid concurrent builds of the same type.
	touch "${LOCKFILE}"

	# Build multi arch manifest ih requested
	if [ ${#ARCHES[@]} -gt 1 ]; then
		podman manifest exists "${REG_ADDR}/${REG_USER}/${PROJECT}:latest" &&
			podman manifest rm "${REG_ADDR}/${REG_USER}/${PROJECT}:latest"
		podman manifest create "${REG_ADDR}/${REG_USER}/${PROJECT}:latest"

		if [ ${#ARCHES[@]} -gt 1 ]; then
			for arch in "${ARCHES[@]}"; do
				podman_args=()
				# Use our own base image if we are building a ricv64 image
				if [ "$arch" == "riscv64" ]; then
					podman_args+=(--from docker.io/dirk1980/fedora-riscv64:latest)
				fi

				# Encrypt image if enabled
				if [ "$ENCRYPT" == true ]; then
					podman_args+=(--encryption-key="$ENCRYPT_KEY")
				fi
				podman_args+=(
					--rm
					--arch "$arch"
					--build-arg "buildid=${BUILD_ID}"
					--security-opt label=type:unconfined_t
					--pull=always
					--network host
					-t "${REG_ADDR}/${REG_USER}/${PROJECT}:$arch" "${WORKDIR}"
				)
				# shellcheck disable=SC2086
				podman build "${podman_args[@]}"

				podman manifest add "${REG_ADDR}/${REG_USER}/${PROJECT}:latest" \
					"${REG_ADDR}/${REG_USER}/${PROJECT}:$arch"
			done
		fi

		for arch in "${ARCHES[@]}"; do
			# Remove trmporary tags.
			podman image untag "${REG_ADDR}/${REG_USER}/${PROJECT}:$arch"
		done

		# Sign and Upload image to the registry if requested
		if [ "$UPLOAD" == "true" ]; then
			podman manifest push \
				--authfile "${AUTHFILE}" \
				--sign-by-sigstore-private-key "${SIGN_PRIVATE_KEY}" \
				--sign-passphrase-file "${SIGN_PASSWORD_FILE}" \
				"${REG_ADDR}/${REG_USER}/${PROJECT}:latest"
		fi
	elif [ ${#ARCHES[@]} -eq 1 ]; then
		for arch in "${ARCHES[@]}"; do
			podman_args=()
			# Use our own base image if we are building a ricv64 image
			if [ "$arch" == "riscv64" ]; then
				podman_args+=(--from docker.io/dirk1980/fedora-riscv64:latest)
			fi

			# Encrypt image if enabled
			if [ "$ENCRYPT" == true ]; then
				podman_args+=(--encryption-key="$ENCRYPT_KEY")
			fi

			podman_args+=(
				--arch "$arch"
				--rm
				--build-arg buildid="${BUILD_ID}"
				--security-opt label=type:unconfined_t
				--pull=always
				--network host
				-t "${REG_ADDR}/${REG_USER}/${PROJECT}:latest" "${WORKDIR}"
			)

			# shellcheck disable=SC2086
			# Build single arch image
			podman build "${podman_args[@]}"

			# Sign and Upload image to the registry if requested
			if [ "$UPLOAD" == "true" ]; then
				podman push \
					--authfile "${AUTHFILE}" \
					--sign-by-sigstore-private-key "${SIGN_PRIVATE_KEY}" \
					--sign-passphrase-file "${SIGN_PASSWORD_FILE}" \
					"${REG_ADDR}/${REG_USER}/${PROJECT}:latest"
			fi
		done
	fi
fi
