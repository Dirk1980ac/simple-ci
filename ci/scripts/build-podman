#!/bin/env bash

# SPDX-License-Identifier: MIT

# Exit on error and on unbound variables
set -eu

# Initialize script variables because we use 'set -u' and set sane defaults.
# Do not edit these, use the cinfig file instead.
PROJECT=""
WORKDIR=""
UPLOAD="false"
SIGN="false"
BUILD_ID="missing"
ARCHES=()
ADD_KEYS="false"
CONFIG=""
ENCRYPT="false"
RUN_HOST=""
CONTAINERFILE=""

# Print a hopefully useful help text.
help() {
	cat << EOF
Usage: $(basename "$0") [OPTIONS]

This script builds a multi-architecture Podman image for a specified project
and can optionally upload it, targeting either a 'stable' or 'nightly' release.

Options:
  -c, --config
      Configuration file.
  -p <project>, --project=<project>
      Sets the **project name**. This option is **mandatory**.

  -w <directory>, --workdir=<directory>
      Specifies the **working directory** where the build context is located.
      This option is **mandatory**.

  -b <id>, --build-id=<id>
      Assigns a **build ID** to the image, which can be used for versioning or tracking.
      This option is **mandatory**.

  -h, --help
      Displays this help message and exits.

Examples:
  bootc-build -p myapp -w ./src -b 12345 -t nightly --upload
  bootc-build --project=another-app --workdir=/opt/build/app --build-id=v1.2.0 --target=stable
  bootc-build -p test-project -w /tmp/build -b abc-789 -t nightly -u

EOF
	exit 1
}

# Parse command line options
if ! ARGS=$(getopt -o p:w:b:hc: --long project:,workdir:,build-id:,help,,config: -n "build-podman" -- "$@"); then
	echo "Error: Failed to parse options. Please check your command." >&2
	help
fi

eval set -- "${ARGS}"

while true; do
	case "$1" in
		-p | --project)
			PROJECT=$2
			shift 2
			;;
		-w | --workdir)
			WORKDIR=$2
			shift 2
			;;
		-b | --build-id)
			BUILD_ID=$2
			shift 2
			;;
		-h | --help)
			help
			;;
		-c | --config)
			CONFIG=$2
			shift 2
			;;
		--) # End of options
			shift
			break
			;;
		*)
			echo "Internal error in option parsing!" >&2
			exit 1
			;;
	esac
done

# Show help if a mandatory option is missing
if [[ -z ${PROJECT}   ]] || [[ -z ${BUILD_ID}   ]] || [[ -z ${WORKDIR}   ]]; then
	echo "Error: Mandatory options --project, --build-id or --workdir missing." >&2
	help
fi
cd "${WORKDIR}"

# Read configuration from ${HOME}/.config/ci/containers.conf if available
if [[ -z ${CONFIG} ]] || [[ ! -f ${CONFIG} ]]; then
	echo "Missing config file!"
	exit 1
else
	# shellcheck source=/dev/null
	source "${CONFIG}"
fi

if [[ -z ${REG_USER} ]] || [[ -z ${REG_ADDR} ]]; then
	echo "Please edit the configuration file!"
	exit 1
fi

if   [[ -z ${TAG} ]]; then
	TAG="latest"
fi

LOCKFILE="${HOME}/.ci/lock/.${PROJECT}-${TAG}-running"

# cleanup function
cleanup() {
	# Remove lock file
	rm -f "${LOCKFILE}"
}

# Trap for cleanup: Ensures lock file is removed even on script to error or signal.
trap cleanup EXIT

# Check if the desired build is already running
if [[ ! -f ${LOCKFILE}  ]]; then

	# Unlock repository if git-crypt is used
	if [[ -d .git-crypt ]]; then
		git --git-dir .git --work-tree . crypt unlock
	fi

	# Lock the build to avoid concurrent builds of the same type.
	touch "${LOCKFILE}"

	# Build multi arch manifest ih requested
	if [[ ${#ARCHES[@]} -gt 1 ]]; then
		podman manifest exists "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}" &&
			podman manifest rm "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}"
		podman manifest create "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}"

		for arch in "${ARCHES[@]}"; do
			podman_args=()
			if [[ ${arch} == "amd64" ]] && [[ -n ${AMD64_REMOTE} ]]; then
				RUN_HOST="${AMD64_REMOTE}"
			elif [[ ${arch} == "arm64" ]] && [[ -n ${ARM64_REMOTE} ]]; then
				RUN_HOST="${ARM64_REMOTE}"
			elif [[ ${arch} == "riscv64" ]] && [[ -n ${RISCV64_REMOTE} ]]; then
				RUN_HOST="${RISCV64_REMOTE}"
			fi

			if [[ ${ADD_KEYS} == true ]]; then
				podman_args+=(--build-arg sshkeys="$(cat "${SSH_KEYFILE}")")
			fi

			if [[ -n ${RUN_HOST} ]]; then
				podman_args+=(-c "${RUN_HOST}")
			fi

			# Use our own base image if we are building a ricv64 image as long
			# as Fedora does not provide an official base image.
			if [[ ${arch} == "riscv64" ]]; then
				podman_args+=(--from docker.io/dirk1980/fedora-riscv64:latest)
			fi

			if [[ -n ${CONTAINERFILE} ]]; then
				podman_args+=(-f "${CONTAINERFILE}")
			fi

			podman_args+=(
				--rm
				--arch "${arch}"
				--build-arg "buildid=${BUILD_ID}"
				--security-opt label=type:unconfined_t
				--pull=always
				--network host
				-t "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}-${arch}"
				"${WORKDIR}"
			)

			# Run the build
			podman build "${podman_args[@]}"

			# Download imaghe from build host if we built remotely
			if [[ -n ${RUN_HOST} ]]; then
				podman image scp \
					"${RUN_HOST}::${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}-${arch}" \
					localhost::
			fi

			# Add image to manifest
			podman manifest add "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}" \
				"${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}-${arch}"
		done

		for arch in "${ARCHES[@]}"; do
			# Remove trmporary tags.
			podman image untag "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}-${arch}"
		done

		# Sign and Upload image to the registry if requested
		if [[ ${UPLOAD} == "true" ]] || [[ ${UPLOAD} == "yes" ]]; then
			push_args=(--authfile "${AUTHFILE}")

			# Encrypt image if enabled
			if [[ ${ENCRYPT} == "true" ]] || [[ ${ENCRYPT} == "yes" ]]; then
				push_args+=(--encryption-key="${ENCRYPT_KEY}")
			fi

			# Images are only signed if private key and password file are set.
			# If they are not set or the file does not exist, then the image
			# will be pushed unsigned.
			if [[ ${SIGN} == "true" ]] ||
				[[ ${SIGN} == "yes" ]] &&
				[[ -f ${SIGN_PRIVATE_KEY} ]] &&
				[[ -f ${SIGN_PASSWORD_FILE} ]]; then
				push_args+=(
					--sign-by-sigstore-private-key "${SIGN_PRIVATE_KEY}"
					--sign-passphrase-file "${SIGN_PASSWORD_FILE}")
			fi

			push_args+=("${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}")

			podman manifest push "${push_args[@]}"
		fi
	elif [[ ${#ARCHES[@]} -eq 1 ]]; then
		for arch in "${ARCHES[@]}"; do
			podman_args=()
			if [[ ${arch} == "amd64" ]] && [[ -n ${AMD64_REMOTE} ]]; then
				RUN_HOST="${AMD64_REMOTE}"
			elif [[ ${arch} == "arm64" ]] && [[ -n ${ARM64_REMOTE} ]]; then
				RUN_HOST="${ARM64_REMOTE}"
			elif [[ ${arch} == "riscv64" ]] && [[ -n ${RISCV64_REMOTE} ]]; then
				RUN_HOST="${RISCV64_REMOTE}"
			fi

			if [[ -n ${RUN_HOST} ]]; then
				podman_args+=(-c "${RUN_HOST}")
			fi

			# Use our own base image if we are building a ricv64 image
			if [[ ${arch} == "riscv64" ]]; then
				podman_args+=(--from docker.io/dirk1980/fedora-riscv64:latest)
			fi

			if [[ -n ${CONTAINERFILE} ]]; then
				podman_args+=(-f "${CONTAINERFILE}")
			fi

			if [[ ${ADD_KEYS} == "true" ]] || [[ ${ADD_KEYS} == "yes" ]]; then
				podman_args+=(--build-arg sshkeys="$(cat "${SSH_KEYFILE}")")
			fi

			podman_args+=(
				--arch "${arch}"
				--rm
				--memory 1g
				--build-arg buildid="${BUILD_ID}"
				--security-opt label=type:unconfined_t
				--pull=always
				--network host
				-t "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}" "${WORKDIR}"
			)

			# Build single arch image
			podman build "${podman_args[@]}"

			# Download imaghe from build host if we built remotely
			if [[ -n ${RUN_HOST} ]]; then
				podman image scp \
					"${RUN_HOST}::${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}" \
					localhost::
			fi

			# Sign and Upload image to the registry if requested
			if [[ ${UPLOAD} == "true" ]] || [[ ${UPLOAD} == "yes" ]]; then
				push_args=()

				# Encrypt image if enabled
				if [[ ${ENCRYPT} == true ]]; then
					push_args+=(--encryption-key="${ENCRYPT_KEY}")
				fi

				# Images are only signed if private key and password file are
				# set. If they are not set or the file does not exist, then the
				# image will be pushed unsigned.
				if [[ ${SIGN} == "true" ]] ||
					[[ ${SIGN} == "yes" ]] &&
					[[ -f ${SIGN_PRIVATE_KEY} ]] &&
					[[ -f ${SIGN_PASSWORD_FILE} ]]; then
					push_args+=(
						--sign-by-sigstore-private-key "${SIGN_PRIVATE_KEY}"
						--sign-passphrase-file "${SIGN_PASSWORD_FILE}")
				fi

				push_args+=(
					--authfile "${AUTHFILE}"
					"${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}"
				)

				podman push "${push_args[@]}"
			fi
		done
	fi

	# Lock repository after run if git-crypt is used.
	if [[ -d .git-crypt ]]; then
		git --git-dir .git --work-tree . crypt lock
	fi
fi
