#!/bin/env bash

# SPDX-License-Identifier: MIT

# Exit on error and on unbound variables
set -eu

# Initialize script variables because we use 'set -u' and set sane defaults.
# These variables will be overridden by the config file.
PIPELINE=""
PROJECT=""
WORKDIR=""
BUILD_ID=""
CONFIG=""
BOOTC_SECUREBOOT_SIGN="false"
AMD64_REMOTE=""
ARM64_REMOTE=""
RISCV64_REMOTE=""
BUILDSCRIPT=""
SCRIPT_ARGS=""
RUNNER=""
OUTPUT_DIR=""
OUTPUT_MOUNT=""
UPLOAD="false"
TAG="latest"
ARCHES=()
SQUASH="false"
DISABLE_CACHE="false"
ENCRYPT="false"
ENCRYPT_KEY=""
SIGN="true"
EMBED_KEYS="false"
SSH_KEYFILE=""
CONTAINERFILE=""
BUILD_ARGS=()
REG_USER=""
REG_ADDR=""
BRANCH=""
BOOTC_SECUREBOOT_SCOPE=""

help() {
	cat << EOF
Usage: $(basename "$0") [OPTIONS]

This script builds a multi-architecture Podman image or runs a generic build.
The workflow is determined by the 'PIPELINE' variable in the config file.

Options:
  -c <config_file>, --config <config_file>
      Configuration file.
  -p <project>, --project=<project>
      Sets the **project name**. This option is **mandatory**.
  -w <directory>, --workdir=<directory>
      Specifies the **working directory** where the build context is located.
      This option is **mandatory**.
  --build-id=<id>
      Assigns a **build ID** to the image, which can be used for versioning or tracking.
      This option is **mandatory**.
  --branch
      Branch which is being built.
  -h, --help
      Displays this help message and exits.

Examples:
  $(basename "$0") -p myapp -w ./src -b 12345 --config myconfig.conf
EOF
	exit 1
}

# Parse command line options
if ! ARGS=$(getopt -o p:w:hc: --long project:,workdir:,build-id:,branch:,help,config: -n "$(basename "$0")" -- "$@"); then
	echo "Error: Failed to parse options. Please check your command." >&2
	help
fi

eval set -- "${ARGS}"

while true; do
	case "$1" in
		-p | --project)
			PROJECT=$2
			shift 2
			;;
		-w | --workdir)
			WORKDIR=$2
			shift 2
			;;
		--build-id)
			BUILD_ID=$2
			shift 2
			;;
		--branch)
			BRANCH=$2
			shift 2
			;;
		-h | --help)
			help
			;;
		-c | --config)
			CONFIG=$2
			shift 2
			;;
		--)
			shift
			break
			;;
		*)
			echo "Internal error in option parsing!" >&2
			exit 1
			;;
	esac
done

# Show help if a mandatory option is missing
if [[ -z ${PROJECT} ]] || [[ -z ${BUILD_ID} ]] || [[ -z ${WORKDIR} ]]; then
	echo "Error: Mandatory options --project, --build-id or --workdir missing." >&2
	help
fi

cd "${WORKDIR}"

# Read configuration file
if [[ -z ${CONFIG} ]] || [[ ! -f ${CONFIG} ]]; then
	echo "Missing config file!"
	exit 1
else
	# shellcheck source=/dev/null
	source "${CONFIG}"
fi

SIGN_PRIVATE_KEY="${HOME}/.config/simple-ci/secrets/${REG_USER}.private"
SIGN_PASSWORD_FILE="${HOME}/.config/simple-ci/secrets/${REG_USER}.pw"

if [[ ${SIGN} == "true" ]]; then
	if [[ ! -f ${SIGN_PRIVATE_KEY} ]] || [[ ! -f ${SIGN_PASSWORD_FILE} ]]; then
		echo "Missing image signature key or password file!"
		exit 1
	fi
fi

if  [[ ${BOOTC_SECUREBOOT_SIGN} == "true" ]] &&
	[[ -z ${BOOTC_SECUREBOOT_SCOPE} ]]; then
	echo "Secureboot signing requested but missing secureboot scope."
	exit 1
fi

BOOTC_SIGN_KEY="${HOME}/.config/simple-ci/secrets/${BOOTC_SECUREBOOT_SCOPE}.db.key"
BOOTC_SIGN_CERT="${HOME}/.config/simple-ci/secrets/${BOOTC_SECUREBOOT_SCOPE}.db.pem"

if [[ ${BOOTC_SECUREBOOT_SIGN} == "true" ]]; then
	if [[ ! -f ${BOOTC_SIGN_KEY} ]] || [[ -f ${BOOTC_SIGN_CERT} ]]; then
		echo "Missing Secureboot Signature key or cert!"
		exit 1
	fi
fi

cleanup() {
	rm -f "${LOCKFILE}"
}

trap cleanup EXIT

case "${PIPELINE}" in
	"podman" | "docker")
		# Podman/Docker Workflow
		if [[ ${UPLOAD} == "true" ]] && [[ -z ${REG_USER} ]] || [[ -z ${REG_ADDR} ]]; then
			echo "UPLOAD is true but no target is specified, disabling Upload."
			UPLOAD="false"
		fi

		if [[ -z ${TAG} ]]; then
			TAG="latest"
		fi

		LOCKFILE="${HOME}/.ci/lock/.${PROJECT}-${TAG}-running"

		if [[ ! -f ${LOCKFILE} ]]; then
			touch "${LOCKFILE}"

			if [[ -d .git-crypt ]]; then
				git --git-dir .git --work-tree . crypt unlock
			fi

			if [[ ${#ARCHES[@]} -gt 1 ]]; then
				podman manifest exists "${PROJECT}:${TAG}" &&
					podman manifest rm "${PROJECT}:${TAG}"
				podman manifest create "${PROJECT}:${TAG}"

				for arch in "${ARCHES[@]}"; do
					RUN_HOST=""
					podman_args=()

					if [[ ${arch} == "amd64" ]] && [[ -n ${AMD64_REMOTE} ]]; then
						RUN_HOST="${AMD64_REMOTE}"
					elif [[ ${arch} == "arm64" ]] && [[ -n ${ARM64_REMOTE} ]]; then
						RUN_HOST="${ARM64_REMOTE}"
					elif [[ ${arch} == "riscv64" ]] && [[ -n ${RISCV64_REMOTE} ]]; then
						RUN_HOST="${RISCV64_REMOTE}"
					fi

					if [[ ${BOOTC_SECUREBOOT_SIGN} == "true" ]]; then
						podman_args+=(
							"--secret id=secure_key,src=${BOOTC_SIGN_KEY}"
							"--secret id=secure_cert,src=${BOOTC_SIGN_CERT}"
						)
					fi

					if [[ ${EMBED_KEYS} == "true" ]] ||
						[[ ${EMBED_KEYS} == "yes" ]]; then
						podman_args+=(
							--build-arg sshkeys="$(cat "${SSH_KEYFILE}")"
						)
					fi

					for arg in "${BUILD_ARGS[@]}"; do
						podman_args+=(--build-arg "${arg}")
					done

					if [[ -n ${RUN_HOST} ]]; then
						podman_args+=(-c "${RUN_HOST}")
					fi

					if [[ ${arch} == "riscv64" ]]; then
						podman_args+=(
							--from docker.io/dirk1980/fedora-riscv64:latest
						)
					fi

					if [[ -n ${CONTAINERFILE} ]]; then
						podman_args+=(-f "${CONTAINERFILE}")
					fi

					if [[ ${SQUASH} == "true" ]] || [[ ${SQUASH} == "yes" ]]; then
						podman_args+=(--squash-all)
					fi

					if [[ ${DISABLE_CACHE} == "true" ]] ||
						[[ ${DISABLE_CACHE} == "yes" ]]; then
						podman_args+=(--no-cache)
					fi

					podman_args+=(
						--rm
						--arch "${arch}"
						--build-arg "buildid=${BUILD_ID}"
						--security-opt label=type:unconfined_t
						--pull=always
						--network host
						-t "${PROJECT}:${TAG}-${arch}"
						"${WORKDIR}"
					)
					podman build "${podman_args[@]}"

					if [[ -n ${RUN_HOST} ]]; then
						podman image scp \
							"${RUN_HOST}::${PROJECT}:${TAG}-${arch}" \
							localhost::
					fi

					podman manifest add \
						"${PROJECT}:${TAG}" \
						"${PROJECT}:${TAG}-${arch}"
				done

				for arch in "${ARCHES[@]}"; do
					podman image untag \
						"${PROJECT}:${TAG}-${arch}"
				done

				if [[ ${UPLOAD} == "true" ]] || [[ ${UPLOAD} == "yes" ]]; then
					if [[ ${ENCRYPT} == "true" ]] || [[ ${ENCRYPT} == "yes" ]]; then
						push_args+=(--encryption-key="${ENCRYPT_KEY}")
					fi
					if [[ ${SIGN} != "false" ]] &&
						[[ -f ${SIGN_PRIVATE_KEY} ]] &&
						[[ -f ${SIGN_PASSWORD_FILE} ]]; then
						push_args+=(
							--sign-by-sigstore-private-key "${SIGN_PRIVATE_KEY}"
							--sign-passphrase-file "${SIGN_PASSWORD_FILE}")
					fi
					push_args+=("${PROJECT}:${TAG}")
					push_args+=("${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}")
					podman manifest push "${push_args[@]}"
				fi
			elif [[ ${#ARCHES[@]} -eq 1 ]]; then
				for arch in "${ARCHES[@]}"; do
					RUN_HOST=""
					podman_args=()

					if [[ ${arch} == "amd64" ]] && [[ -n ${AMD64_REMOTE} ]]; then
						RUN_HOST="${AMD64_REMOTE}"
					elif [[ ${arch} == "arm64" ]] &&
						[[ -n ${ARM64_REMOTE} ]]; then
						RUN_HOST="${ARM64_REMOTE}"
					elif [[ ${arch} == "riscv64" ]] &&
						[[ -n ${RISCV64_REMOTE} ]]; then
						RUN_HOST="${RISCV64_REMOTE}"
					fi

					if [[ -n ${RUN_HOST} ]]; then
						podman_args+=(-c "${RUN_HOST}")
					fi

					if [[ ${BOOTC_SECUREBOOT_SIGN} == "true" ]]; then
						podman_args+=(
							"--secret id=secure_key,src=${BOOTC_SIGN_KEY}"
							"--secret id=secure_cert,src=${BOOTC_SIGN_CERT}"
						)
					fi

					if [[ ${arch} == "riscv64" ]]; then
						podman_args+=(--from docker.io/dirk1980/fedora-riscv64:latest)
					fi

					if [[ -n ${CONTAINERFILE} ]]; then
						podman_args+=(-f "${CONTAINERFILE}")
					fi

					if [[ ${SQUASH} == "true" ]]; then
						podman_args+=(--squash-all)
					fi

					if [[ ${EMBED_KEYS} == "true" ]] ||
						[[ ${EMBED_KEYS} == "yes" ]]; then
						podman_args+=(--build-arg sshkeys="$(cat "${SSH_KEYFILE}")")
					fi

					podman_args+=(
						--arch "${arch}"
						--rm
						--build-arg buildid="${BUILD_ID}"
						--security-opt label=type:unconfined_t
						--pull=always
						--network host
						-t "${PROJECT}:${TAG}" "${WORKDIR}"
					)

					podman image exists "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}" &&
						podman image rm "${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}" --force

					podman build "${podman_args[@]}"

					if [[ -n ${RUN_HOST} ]]; then
						podman image scp \
							"${RUN_HOST}::${PROJECT}:${TAG}" \
							localhost::
					fi

					if [[ ${UPLOAD} == "true" ]] || [[ ${UPLOAD} == "yes" ]]; then
						push_args=()
						if [[ ${ENCRYPT} == true ]]; then
							push_args+=(--encryption-key="${ENCRYPT_KEY}")
						fi

						if [[ ${SIGN} != "false" ]] &&
							[[ -f ${SIGN_PRIVATE_KEY} ]] &&
							[[ -f ${SIGN_PASSWORD_FILE} ]]; then
							push_args+=(
								--sign-by-sigstore-private-key "${SIGN_PRIVATE_KEY}"
								--sign-passphrase-file "${SIGN_PASSWORD_FILE}")
						fi

						push_args+=(
							"${PROJECT}:${TAG}"
							"${REG_ADDR}/${REG_USER}/${PROJECT}:${TAG}"
						)
						podman push "${push_args[@]}"
					fi
				done
			fi

			if [[ -d .git-crypt ]]; then
				git --git-dir .git --work-tree . crypt lock
			fi
		fi
		;;
	"generic")
		# Generic Workflow
		LOCKFILE="${HOME}/.ci/lock/.${PROJECT}-${BRANCH}-running"

		if [[ ! -f ${LOCKFILE} ]]; then

			if [[ -d .git-crypt ]]; then
				git --git-dir .git --work-tree . crypt unlock
			fi

			for arch in "${ARCHES[@]}"; do
				RUN_HOST=""
				podman_args=()

				if [[ ${arch} == "amd64" ]] && [[ -n ${AMD64_REMOTE} ]]; then
					RUN_HOST="${AMD64_REMOTE}"
				elif [[ ${arch} == "arm64" ]] && [[ -n ${ARM64_REMOTE} ]]; then
					RUN_HOST="${ARM64_REMOTE}"
				elif [[ ${arch} == "riscv64" ]] && [[ -n ${RISCV64_REMOTE} ]]; then
					RUN_HOST="${RISCV64_REMOTE}"
				fi

				if [[ -n ${RUN_HOST} ]]; then
					podman_args+=(-c "${RUN_HOST}")
				fi

				podman_args+=(
					--rm
					--memory 1g
					--pull=always
					--arch "${arch}"
					--security-opt label=type:unconfined_t
					-v "${WORKDIR}:/workdir"
				)

				if [[ -n ${OUTPUT_DIR} ]] && [[ -n ${OUTPUT_MOUNT} ]]; then
					podman_args+=(-v "${HOME}/${OUTPUT_DIR}:${OUTPUT_MOUNT}")
				fi

				if [[ -z ${RUNNER} ]]; then
					RUNNER="docker.io/dirk1980/simple-ci-generic:latest"
				fi

				podman_args+=(
					"${RUNNER}"
				)

				if [[ -n ${BUILDSCRIPT} ]]; then
					podman_args+=(
						"${BUILDSCRIPT}"
						"${SCRIPT_ARGS}"
					)
				fi

				timeout 2h podman run "${podman_args[@]}"
			done

			if [[ -d .git-crypt ]]; then
				git --git-dir .git --work-tree . crypt lock
			fi
		fi
		;;
	*)
		echo "Error: Unknown pipeline '${PIPELINE}' specified in config file." >&2
		exit 1
		;;
esac
